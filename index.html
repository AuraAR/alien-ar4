<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RECLUSIA - Bioluminescent AR</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        body { background:#000; font-family:'Courier New',monospace; overflow:hidden; position:fixed; width:100%; height:100vh; color:#00ff88; }
        #videoContainer { position:relative; width:100vw; height:100vh; overflow:hidden; }
        #cameraFeed { width:100%; height:100%; object-fit:cover; transform:scaleX(-1); filter:brightness(1.3) contrast(1.08) saturate(1.05); }
        #arCanvas { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:2; }
        .controls { position:absolute; bottom:30px; left:50%; transform:translateX(-50%); display:flex; gap:15px; z-index:10; }
        .btn { width:60px; height:60px; border-radius:50%; border:3px solid #00ff88; background:rgba(0,0,0,0.8); color:#00ff88; font-size:20px; cursor:pointer; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(10px); transition:all 0.3s ease; box-shadow:0 0 15px rgba(0,255,136,0.3); user-select:none; }
        .btn:active { transform:scale(0.9); box-shadow:0 0 25px rgba(0,255,136,0.6); }
        .btn.active { background:rgba(0,255,136,0.2); box-shadow:0 0 20px rgba(0,255,136,0.5); }
        .status { position:absolute; top:20px; left:50%; transform:translateX(-50%); color:#00ff88; text-align:center; font-size:12px; background:rgba(0,0,0,0.7); padding:8px 15px; border-radius:20px; backdrop-filter:blur(10px); border:1px solid rgba(0,255,136,0.3); z-index:10; white-space:nowrap; }
        .start-screen { position:absolute; top:0; left:0; width:100%; height:100%; background:linear-gradient(135deg,#000011,#001122,#000033); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:100; text-align:center; }
        .start-screen h1 { font-size:38px; margin-bottom:12px; text-shadow:0 0 30px #00ff88; letter-spacing:8px; animation:pulse 2s infinite; }
        .start-screen .sub { font-size:13px; opacity:0.55; letter-spacing:3px; text-transform:uppercase; margin-bottom:8px; }
        .start-screen .perms { font-size:13px; opacity:0.75; margin:18px 0 4px; }
        .start-btn { width:140px; height:140px; border-radius:50%; border:4px solid #00ff88; background:rgba(0,0,0,0.5); color:#00ff88; font-size:16px; cursor:pointer; display:flex; flex-direction:column; align-items:center; justify-content:center; box-shadow:0 0 30px rgba(0,255,136,0.5); transition:all 0.3s ease; margin-top:28px; }
        .start-btn:active { transform:scale(0.95); box-shadow:0 0 40px rgba(0,255,136,0.8); }
        @keyframes pulse { 0%,100%{opacity:1;transform:scale(1)} 50%{opacity:0.7;transform:scale(1.05)} }
        .hidden { display:none !important; }
        .camera-switch { position:absolute; top:20px; right:20px; z-index:10; }
        .instructions { position:absolute; bottom:120px; left:50%; transform:translateX(-50%); text-align:center; color:rgba(0,255,136,0.7); font-size:11px; z-index:10; white-space:nowrap; }
        #bassFlash { position:absolute; inset:0; pointer-events:none; z-index:3; opacity:0; transition:opacity 0.05s; }
        @media(max-width:480px){ .start-screen h1{font-size:26px} .start-btn{width:110px;height:110px} .btn{width:50px;height:50px;font-size:16px} .controls{bottom:20px;gap:10px} }
    </style>
</head>
<body>

<div class="start-screen" id="startScreen">
    <p class="sub">Welcome to</p>
    <h1>RECLUSIA</h1>
    <p class="perms">ğŸ“· Camera + ğŸ¤ Mic required<br><span style="font-size:11px;opacity:0.6">Tap Allow when your browser asks</span></p>
    <button class="start-btn" onclick="startAR()">
        <div>ğŸŒŒ</div>
        <div style="margin-top:5px;font-size:13px;letter-spacing:2px;">ENTER</div>
    </button>
</div>

<div id="videoContainer" class="hidden">
    <video id="cameraFeed" autoplay muted playsinline></video>
    <canvas id="arCanvas"></canvas>
    <div id="bassFlash"></div>
</div>

<div class="status hidden" id="status">Initializing...</div>

<div class="controls hidden" id="controls">
    <button class="btn" id="micBtn"    title="Toggle Audio">ğŸ¤</button>
    <button class="btn" id="plantsBtn" title="Toggle Plants">ğŸŒ¿</button>
    <button class="btn" id="alienBtn"  title="Alien Face">ğŸ‘½</button>
    <button class="btn" id="colorBtn"  title="Change Colors">ğŸ¨</button>
</div>

<div class="camera-switch hidden" id="cameraSwitch">
    <button class="btn" id="flipBtn" title="Flip Camera">ğŸ”„</button>
</div>

<div class="instructions hidden" id="instructions">
    ğŸ¤ audio reactive â€¢ ğŸ‘½ alien morph â€¢ ğŸ¨ palette
</div>

<script>
// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let video, canvas, ctx;
let audioContext, analyser, microphone;
let plants = [], particles = [];
let micActive=false, cameraActive=false, plantsActive=true, alienActive=false;
let facingMode='user', currentColors=0, time=0;
let W=0, H=0;

// Face mesh
let faceMesh=null, faceResults=null, faceMeshReady=false, mpCamera=null;

// Smoothed audio bands
let smoothBass=0, smoothMid=0, smoothHigh=0, smoothAvg=0;
let rawHigh=0; // un-smoothed for snare detection
let lastSnare=0, lastBassHit=0;

// â”€â”€ Palettes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PAL = [
    { stem:'rgba(0,185,140,0.82)',  leaf:'rgba(0,215,165,0.68)', spore:'rgba(90,255,195,0.55)', slime:'rgba(60,255,160,0.7)',  glow:'#00b98c', flash:'rgba(0,185,140,0.09)' },
    { stem:'rgba(120,60,210,0.78)', leaf:'rgba(160,85,245,0.62)', spore:'rgba(200,140,255,0.52)', slime:'rgba(180,80,255,0.7)', glow:'#8040d0', flash:'rgba(120,60,210,0.09)' },
    { stem:'rgba(205,140,20,0.78)', leaf:'rgba(240,178,38,0.62)', spore:'rgba(255,215,95,0.52)',  slime:'rgba(255,200,40,0.7)', glow:'#cda010', flash:'rgba(205,140,20,0.09)' },
    { stem:'rgba(55,175,255,0.78)', leaf:'rgba(95,210,255,0.62)', spore:'rgba(175,240,255,0.52)', slime:'rgba(80,220,255,0.7)', glow:'#37aff0', flash:'rgba(55,175,255,0.09)' },
    { stem:'rgba(215,78,115,0.78)', leaf:'rgba(252,118,158,0.62)',spore:'rgba(255,175,200,0.52)', slime:'rgba(255,100,150,0.7)',glow:'#d84872', flash:'rgba(215,78,115,0.09)' }
];

// â”€â”€ MediaPipe â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initFaceMesh() {
    if (typeof FaceMesh==='undefined') { console.warn('MediaPipe unavailable'); return; }
    faceMesh = new FaceMesh({ locateFile: f=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
    faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });
    faceMesh.onResults(r=>{ faceResults=r; });
    faceMeshReady=true;
}
function startFaceMeshCamera() {
    if (!faceMeshReady||!faceMesh||typeof Camera==='undefined') return;
    mpCamera = new Camera(video, { onFrame: async()=>{ if(alienActive&&faceMesh) await faceMesh.send({image:video}); }, width:640, height:480 });
    mpCamera.start();
}

// â”€â”€ App Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function startAR() {
    try {
        document.getElementById('startScreen').classList.add('hidden');
        ['videoContainer','status','controls','cameraSwitch','instructions'].forEach(id=>document.getElementById(id).classList.remove('hidden'));
        await initCamera(); await initAudio(); initFaceMesh(); setupControls(); startAnimation(); generateInitialPlants();
    } catch(e) { console.error(e); showError('Init failed â€” check camera permissions'); }
}

async function initCamera() {
    video=document.getElementById('cameraFeed'); canvas=document.getElementById('arCanvas'); ctx=canvas.getContext('2d');
    updateStatus('Requesting camera...');
    const stream=await navigator.mediaDevices.getUserMedia({ video:{facingMode,width:{ideal:1280},height:{ideal:720}} });
    video.srcObject=stream; cameraActive=true;
    updateStatus('ğŸŒ¿ AR Active â€” tap ğŸ‘½ to morph');
    video.addEventListener('loadedmetadata', resizeCanvas);
}
async function initAudio() {
    try { audioContext=new (window.AudioContext||window.webkitAudioContext)(); analyser=audioContext.createAnalyser(); analyser.fftSize=1024; analyser.smoothingTimeConstant=0.75; }
    catch(e) { console.error('Audio:',e); }
}
function resizeCanvas() {
    const r=video.getBoundingClientRect();
    W=canvas.width=r.width||window.innerWidth; H=canvas.height=r.height||window.innerHeight;
    generateInitialPlants();
}
function updateStatus(msg) { const el=document.getElementById('status'); el.textContent=msg; el.style.opacity='1'; setTimeout(()=>el.style.opacity='0.6',3000); }
function showError(m) { updateStatus('âŒ '+m); }

function setupControls() {
    document.getElementById('micBtn').onclick=toggleMicrophone;
    document.getElementById('plantsBtn').onclick=togglePlants;
    document.getElementById('alienBtn').onclick=toggleAlienMode;
    document.getElementById('colorBtn').onclick=switchColors;
    document.getElementById('flipBtn').onclick=flipCamera;
    window.addEventListener('resize',resizeCanvas); resizeCanvas();
}
async function toggleMicrophone() {
    const btn=document.getElementById('micBtn');
    if (!micActive) {
        try {
            if (audioContext?.state==='suspended') await audioContext.resume();
            const stream=await navigator.mediaDevices.getUserMedia({ audio:{echoCancellation:false,noiseSuppression:false,autoGainControl:false} });
            microphone=audioContext.createMediaStreamSource(stream); microphone.connect(analyser);
            micActive=true; btn.classList.add('active'); updateStatus('ğŸµ Audio reactive ON');
        } catch(e) { updateStatus('âŒ Mic denied'); }
    } else {
        microphone?.disconnect(); microphone=null; micActive=false; btn.classList.remove('active'); updateStatus('ğŸ”‡ Audio OFF');
    }
}
function togglePlants() {
    const btn=document.getElementById('plantsBtn'); plantsActive=!plantsActive;
    if (plantsActive) { btn.classList.add('active'); generateInitialPlants(); updateStatus('ğŸŒ¿ Plants growing'); }
    else { btn.classList.remove('active'); plants=[]; updateStatus('ğŸŒ‘ Plants off'); }
}
function toggleAlienMode() {
    const btn=document.getElementById('alienBtn'); alienActive=!alienActive;
    if (alienActive) { btn.classList.add('active'); updateStatus('ğŸ‘½ Alien mode â€” face camera'); if (faceMeshReady&&!mpCamera) startFaceMeshCamera(); }
    else { btn.classList.remove('active'); faceResults=null; updateStatus('ğŸ‘¤ Human restored'); }
}
function switchColors() { currentColors=(currentColors+1)%PAL.length; updateStatus('ğŸ¨ '+['Pandora','Violet','Amber','Arctic','Coral'][currentColors]); }
async function flipCamera() {
    facingMode=facingMode==='user'?'environment':'user'; video.srcObject?.getTracks().forEach(t=>t.stop());
    try { video.srcObject=await navigator.mediaDevices.getUserMedia({ video:{facingMode,width:{ideal:1280},height:{ideal:720}} }); updateStatus(facingMode==='user'?'ğŸ¤³ Front':'ğŸ“· Back'); }
    catch(e) { facingMode=facingMode==='user'?'environment':'user'; updateStatus('âŒ Flip failed'); }
}

// â”€â”€ Audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getAudioData() {
    time+=0.016;
    if (!analyser||!micActive) {
        const d={bass:0.12+Math.sin(time*0.55)*0.07, mid:0.09+Math.sin(time*0.95)*0.05, high:0.07+Math.sin(time*2.0)*0.04, average:0.10+Math.sin(time*1.2)*0.05};
        rawHigh=d.high; doSmooth(d); return d;
    }
    const buf=analyser.frequencyBinCount, data=new Uint8Array(buf);
    analyser.getByteFrequencyData(data);
    const d={ bass:avg(data,0,Math.floor(buf*0.1)), mid:avg(data,Math.floor(buf*0.1),Math.floor(buf*0.45)), high:avg(data,Math.floor(buf*0.45),buf), average:avg(data,0,buf) };
    rawHigh=d.high; doSmooth(d); return d;
}
function doSmooth(d) {
    const k=0.14;
    smoothBass=smoothBass+(d.bass-smoothBass)*k; smoothMid=smoothMid+(d.mid-smoothMid)*k;
    smoothHigh=smoothHigh+(d.high-smoothHigh)*k; smoothAvg=smoothAvg+(d.average-smoothAvg)*k;
}
function avg(arr,s,e) { let sum=0; for(let i=s;i<e;i++) sum+=arr[i]; return (sum/(e-s))/255; }

// â”€â”€ Plants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 8 distinct plant archetypes for variety
const PLANT_TYPES = ['fernBig','fernBig','coral','vine','mushroomCluster','crystal','tendrilBig','bladePalm'];

function generateInitialPlants() {
    if (!plantsActive||!W) return;
    plants=[];
    // Dense bottom row â€” 20 plants spread across full width
    for (let i=0;i<20;i++) {
        const x = (i/19)*W*1.06 - W*0.03 + (Math.random()-0.5)*W*0.04;
        plants.push(makePlant('bottom', x));
    }
    // Left wall â€” 6 plants
    for (let i=0;i<6;i++) plants.push(makePlant('left', H*(0.12+i*0.14+Math.random()*0.06)));
    // Right wall â€” 6 plants
    for (let i=0;i<6;i++) plants.push(makePlant('right', H*(0.12+i*0.14+Math.random()*0.06)));
}

function makePlant(edge, pos) {
    let x, y, dir;
    if      (edge==='bottom') { x=pos; y=H;   dir='up'; }
    else if (edge==='left')   { x=0;   y=pos; dir='right'; }
    else                      { x=W;   y=pos; dir='left'; }
    return {
        x, y, edge, dir,
        type:      PLANT_TYPES[Math.floor(Math.random()*PLANT_TYPES.length)],
        size:      0.55+Math.random()*0.95,   // larger range
        depth:     Math.random(),
        baseLen:   80+Math.random()*160,       // much bigger base lengths
        swayPhase: Math.random()*Math.PI*2,
        glowSeed:  Math.random(),
        swayAmt:0, currentLen:1, birthTime:time
    };
}

function updatePlants() {
    if (!plantsActive) return;
    plants.forEach(p => {
        const growFrac = Math.min((time-p.birthTime)/2.5, 1.0);
        if (!micActive) {
            // Dead still â€” no movement at all without sound input
            p.swayAmt = 0;
            p.currentLen = p.baseLen * p.size * growFrac;
        } else {
            // Beat-driven: bass = big lurch, mid = ripple
            const bassKick = smoothBass > 0.22 ? (smoothBass - 0.22) * 4.2 : 0;
            p.swayAmt = Math.sin(time * 1.8 + p.swayPhase) * (smoothBass * 3.2 + smoothMid * 0.9) * growFrac;
            p.currentLen = p.baseLen * p.size * growFrac * (1 + bassKick * 0.65);
        }
    });
}

// â”€â”€ Plant Renderers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function baseAngleOf(p) {
    if (p.dir==='up')    return -Math.PI/2 + p.swayAmt;
    if (p.dir==='right') return p.swayAmt;
    return Math.PI + p.swayAmt;
}

function drawStem(x,y,len,angle,pal,alpha,lw) {
    if (len<3) return;
    const ex=x+Math.cos(angle)*len, ey=y+Math.sin(angle)*len;
    const cx=x+Math.cos(angle+0.35)*len*0.5, cy=y+Math.sin(angle+0.35)*len*0.5;
    ctx.save();
    ctx.globalAlpha=alpha; ctx.strokeStyle=pal.stem; ctx.lineWidth=lw; ctx.lineCap='round';
    ctx.shadowColor=pal.glow; ctx.shadowBlur=8+smoothAvg*14;
    ctx.beginPath(); ctx.moveTo(x,y); ctx.quadraticCurveTo(cx,cy,ex,ey); ctx.stroke();
    ctx.restore();
    return {ex,ey,cx,cy};
}

// Big fern â€” tall arching stem with large leaf pairs
function drawFernBig(p,pal) {
    const alpha=(0.55+p.depth*0.35)*Math.min((time-p.birthTime)/2,1);
    const lw=2.5+p.depth*2.5;
    const angle=baseAngleOf(p);
    const len=p.currentLen;
    const ex=p.x+Math.cos(angle)*len, ey=p.y+Math.sin(angle)*len;
    const cx=p.x+Math.cos(angle+0.4)*len*0.5, cy=p.y+Math.sin(angle+0.4)*len*0.5;

    ctx.save();
    ctx.globalAlpha=alpha; ctx.strokeStyle=pal.stem; ctx.lineWidth=lw; ctx.lineCap='round';
    ctx.shadowColor=pal.glow; ctx.shadowBlur=10+smoothAvg*18;
    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.quadraticCurveTo(cx,cy,ex,ey); ctx.stroke();

    // Large leaf pairs every 22px
    const steps=Math.floor(len/22);
    for (let i=1;i<=steps;i++) {
        const t=i/steps;
        const lx=p.x+(ex-p.x)*t+(cx-p.x)*t*(1-t)*2;
        const ly=p.y+(ey-p.y)*t+(cy-p.y)*t*(1-t)*2;
        const ls=(8+t*18)*(0.7+p.depth*0.5);
        ctx.fillStyle=pal.leaf; ctx.shadowColor=pal.glow; ctx.shadowBlur=5;
        ctx.globalAlpha=alpha*0.8;
        [-1,1].forEach(s=>{
            ctx.beginPath();
            ctx.ellipse(lx+Math.cos(angle+s*Math.PI/2.2)*ls, ly+Math.sin(angle+s*Math.PI/2.2)*ls, ls*1.1, ls*0.38, angle+s*0.5, 0, Math.PI*2);
            ctx.fill();
        });
    }
    // Glowing tip
    ctx.globalAlpha=alpha*(0.6+smoothAvg*0.4); ctx.fillStyle=pal.spore; ctx.shadowBlur=14+smoothBass*18;
    ctx.beginPath(); ctx.arc(ex,ey,4+smoothBass*5,0,Math.PI*2); ctx.fill();
    ctx.restore();
}

// Coral â€” branching radial structure
function drawCoral(p,pal) {
    const alpha=(0.5+p.depth*0.38)*Math.min((time-p.birthTime)/2,1);
    const lw=3+p.depth*2;
    const angle=baseAngleOf(p);
    const len=p.currentLen;

    ctx.save();
    ctx.shadowColor=pal.glow; ctx.shadowBlur=12+smoothAvg*16;
    // Draw 5-7 branches in a fan
    const branches=5+Math.floor(p.size*2);
    const fanSpread=Math.PI*0.55;
    for (let b=0;b<branches;b++) {
        const bAngle=angle - fanSpread/2 + (b/(branches-1))*fanSpread;
        const bLen=len*(0.55+Math.random()*0.15+(b===Math.floor(branches/2)?0.3:0));
        const ex=p.x+Math.cos(bAngle)*bLen, ey=p.y+Math.sin(bAngle)*bLen;
        const cx=p.x+Math.cos(bAngle+0.2)*bLen*0.55, cy=p.y+Math.sin(bAngle+0.2)*bLen*0.55;
        ctx.globalAlpha=alpha*(0.7+Math.random()*0.3);
        ctx.strokeStyle=b%2===0?pal.stem:pal.leaf; ctx.lineWidth=lw*(0.5+b===Math.floor(branches/2)?0.8:0.3); ctx.lineCap='round';
        ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.quadraticCurveTo(cx,cy,ex,ey); ctx.stroke();
        // Branch tip orb
        ctx.fillStyle=pal.spore; ctx.globalAlpha=alpha*(0.7+smoothAvg*0.3); ctx.shadowBlur=10+smoothBass*12;
        ctx.beginPath(); ctx.arc(ex,ey,3+p.size*3+smoothBass*4,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
}

// Vine â€” thick wavy stem with large leaves
function drawVine(p,pal) {
    const alpha=(0.5+p.depth*0.38)*Math.min((time-p.birthTime)/2,1);
    const lw=2.5+p.depth*2;
    const angle=baseAngleOf(p);
    const len=p.currentLen;

    ctx.save();
    ctx.shadowColor=pal.glow; ctx.shadowBlur=8+smoothAvg*12;
    ctx.strokeStyle=pal.stem; ctx.lineWidth=lw; ctx.lineCap='round'; ctx.globalAlpha=alpha;
    ctx.beginPath(); ctx.moveTo(p.x,p.y);
    const segs=12;
    let prevX=p.x, prevY=p.y;
    for (let i=1;i<=segs;i++) {
        const t=i/segs;
        const nx=p.x+Math.cos(angle)*len*t + Math.sin(t*Math.PI*3+p.swayPhase)*18*t;
        const ny=p.y+Math.sin(angle)*len*t + Math.cos(t*Math.PI*2+p.swayPhase)*8*t;
        ctx.quadraticCurveTo((prevX+nx)/2,(prevY+ny)/2,nx,ny);
        if (i%2===0) {
            const ls=10+t*14;
            ctx.fillStyle=pal.leaf; ctx.globalAlpha=alpha*0.8;
            ctx.beginPath(); ctx.ellipse(nx+Math.cos(angle+1.4)*ls, ny+Math.sin(angle+1.4)*ls, ls,ls*0.35,angle+0.4,0,Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(nx+Math.cos(angle-1.4)*ls, ny+Math.sin(angle-1.4)*ls, ls,ls*0.35,angle-0.4,0,Math.PI*2); ctx.fill();
        }
        prevX=nx; prevY=ny;
    }
    ctx.globalAlpha=alpha; ctx.stroke();
    ctx.restore();
}

// Mushroom cluster â€” 3-5 mushrooms in a group
function drawMushroomCluster(p,pal) {
    const alpha=(0.55+p.depth*0.38)*Math.min((time-p.birthTime)/1.8,1);
    const angle=baseAngleOf(p);
    const count=2+Math.floor(p.size*2.5);
    ctx.save();
    ctx.shadowColor=pal.glow; ctx.shadowBlur=14+smoothAvg*18;

    for (let m=0;m<count;m++) {
        const offset=(m-count/2)*p.currentLen*0.22;
        const mh=p.currentLen*(0.5+m*0.12)*(0.8+Math.sin(time*1.5+m+p.swayPhase)*0.08*smoothBass*3);
        const mx=p.x+Math.cos(angle+Math.PI/2)*offset;
        const my=p.y+Math.sin(angle+Math.PI/2)*offset;
        const ex=mx+Math.cos(angle)*mh, ey=my+Math.sin(angle)*mh;

        // Stem
        ctx.globalAlpha=alpha*0.8; ctx.strokeStyle=pal.leaf; ctx.lineWidth=3+p.depth; ctx.lineCap='round';
        ctx.beginPath(); ctx.moveTo(mx,my); ctx.lineTo(ex,ey); ctx.stroke();

        // Cap
        const capR=mh*0.28+smoothBass*8;
        ctx.globalAlpha=alpha*(0.75+smoothAvg*0.25); ctx.fillStyle=pal.stem;
        ctx.beginPath(); ctx.ellipse(ex,ey,capR,capR*0.5,-Math.PI/6,0,Math.PI*2); ctx.fill();

        // Cap glow
        ctx.globalAlpha=alpha*(0.4+smoothAvg*0.35); ctx.fillStyle=pal.spore; ctx.shadowBlur=16+smoothBass*20;
        ctx.beginPath(); ctx.ellipse(ex,ey,capR*0.5,capR*0.25,-Math.PI/6,0,Math.PI*2); ctx.fill();

        // Spore dots underneath cap
        if (Math.random()<0.06+smoothAvg*0.1) {
            particles.push({ x:ex+(Math.random()-0.5)*capR, y:ey+(Math.random()-0.5)*capR*0.3, vx:(Math.random()-0.5)*0.4, vy:Math.cos(angle)*0.4+0.2, size:1+Math.random()*2, color:pal.spore, glow:pal.glow, life:1.0, fadeRate:0.012, type:'ambient' });
        }
    }
    ctx.restore();
}

// Crystal â€” geometric spire cluster
function drawCrystal(p,pal) {
    const alpha=(0.5+p.depth*0.4)*Math.min((time-p.birthTime)/1.8,1);
    const angle=baseAngleOf(p);
    const spires=2+Math.floor(p.size*2);
    ctx.save();
    ctx.shadowColor=pal.glow; ctx.shadowBlur=16+smoothAvg*20;

    for (let s=0;s<spires;s++) {
        const offset=(s-spires/2)*p.currentLen*0.18;
        const sLen=p.currentLen*(0.6+s*0.08)*(1+smoothBass*0.4);
        const sx=p.x+Math.cos(angle+Math.PI/2)*offset;
        const sy=p.y+Math.sin(angle+Math.PI/2)*offset;
        const ex=sx+Math.cos(angle)*sLen, ey=sy+Math.sin(angle)*sLen;
        const w=sLen*0.14;

        ctx.globalAlpha=alpha*(0.65+smoothAvg*0.2); ctx.fillStyle=pal.stem;
        ctx.save(); ctx.translate((sx+ex)/2,(sy+ey)/2); ctx.rotate(angle+Math.PI/2);
        const fLen=Math.sqrt((ex-sx)**2+(ey-sy)**2);
        ctx.beginPath(); ctx.moveTo(0,-fLen/2); ctx.lineTo(w,0); ctx.lineTo(0,fLen/2); ctx.lineTo(-w,0); ctx.closePath(); ctx.fill();
        ctx.restore();

        // Inner light
        ctx.globalAlpha=alpha*(0.4+smoothAvg*0.4); ctx.fillStyle=pal.spore; ctx.shadowBlur=20+smoothBass*25;
        ctx.beginPath(); ctx.arc((sx+ex)/2,(sy+ey)/2,w*0.5,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
}

// Big tendril â€” thick spiraling vine
function drawTendrilBig(p,pal) {
    const alpha=(0.52+p.depth*0.36)*Math.min((time-p.birthTime)/2,1);
    const lw=2+p.depth*2.5;
    const angle=baseAngleOf(p);
    const len=p.currentLen;

    ctx.save();
    ctx.strokeStyle=pal.stem; ctx.lineWidth=lw; ctx.lineCap='round'; ctx.globalAlpha=alpha;
    ctx.shadowColor=pal.glow; ctx.shadowBlur=8+smoothAvg*14;
    ctx.beginPath(); ctx.moveTo(p.x,p.y);
    const segs=20;
    for (let i=1;i<=segs;i++) {
        const t=i/segs;
        const spiral=Math.sin(t*Math.PI*5+time*1.2+p.swayPhase)*t*22*(1+smoothBass*1.5);
        const nx=p.x+Math.cos(angle)*len*t+Math.cos(angle+Math.PI/2)*spiral;
        const ny=p.y+Math.sin(angle)*len*t+Math.sin(angle+Math.PI/2)*spiral;
        ctx.lineTo(nx,ny);
        if (i%4===0) {
            ctx.globalAlpha=alpha*(0.5+smoothAvg*0.4); ctx.fillStyle=pal.spore; ctx.shadowBlur=7+smoothBass*10;
            ctx.beginPath(); ctx.arc(nx,ny,2.5+smoothBass*3,0,Math.PI*2); ctx.fill();
            ctx.globalAlpha=alpha; ctx.strokeStyle=pal.stem;
        }
    }
    ctx.stroke();
    ctx.restore();
}

// Blade palm â€” wide flat blade leaves fanning from base
function drawBladePalm(p,pal) {
    const alpha=(0.55+p.depth*0.35)*Math.min((time-p.birthTime)/2,1);
    const angle=baseAngleOf(p);
    const blades=4+Math.floor(p.size*3);
    const spread=Math.PI*0.7;

    ctx.save();
    ctx.shadowColor=pal.glow; ctx.shadowBlur=10+smoothAvg*16;

    for (let b=0;b<blades;b++) {
        const bAngle=angle-spread/2+(b/(blades-1))*spread;
        const bLen=p.currentLen*(0.7+Math.abs(Math.sin(b/(blades-1)*Math.PI))*0.4);
        const ex=p.x+Math.cos(bAngle)*bLen, ey=p.y+Math.sin(bAngle)*bLen;
        const bw=bLen*0.12;

        ctx.globalAlpha=alpha*(0.65+smoothAvg*0.2); ctx.fillStyle=b%2===0?pal.stem:pal.leaf;
        ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(bAngle);
        ctx.beginPath(); ctx.moveTo(0,0); ctx.quadraticCurveTo(bw,bLen*0.5,0,bLen); ctx.quadraticCurveTo(-bw,bLen*0.5,0,0); ctx.closePath(); ctx.fill();
        ctx.restore();

        // Tip glow
        ctx.globalAlpha=alpha*(0.45+smoothAvg*0.4); ctx.fillStyle=pal.spore; ctx.shadowBlur=12+smoothBass*16;
        ctx.beginPath(); ctx.arc(ex,ey,3+p.size*3+smoothBass*5,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
}

function renderPlants() {
    if (!plantsActive) return;
    const pal=PAL[currentColors];
    [...plants].sort((a,b)=>a.depth-b.depth).forEach(p=>{
        if (p.currentLen<3) return;
        ctx.globalCompositeOperation='screen';
        switch(p.type) {
            case 'fernBig':         drawFernBig(p,pal); break;
            case 'coral':           drawCoral(p,pal); break;
            case 'vine':            drawVine(p,pal); break;
            case 'mushroomCluster': drawMushroomCluster(p,pal); break;
            case 'crystal':         drawCrystal(p,pal); break;
            case 'tendrilBig':      drawTendrilBig(p,pal); break;
            case 'bladePalm':       drawBladePalm(p,pal); break;
        }
    });
}

// â”€â”€ Alien Face â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const L_EYE=[33,7,163,144,145,153,154,155,133,173,157,158,159,160,161,246];
const R_EYE=[362,382,381,380,374,373,390,249,263,466,388,387,386,385,384,398];
const JAWL=[234,93,132,58,172,136,150,149,176,148,152];
const JAWR=[454,323,361,288,397,365,379,378,400,377,152];
const CHIN_IDX=152, TOP_IDX=10;

function lm(lms,idx) { const l=lms[idx]; return {x:(1-l.x)*W,y:l.y*H}; }

function renderAlienFace() {
    if (!alienActive) return;
    if (faceResults?.multiFaceLandmarks?.length>0) drawTrackedAlien(faceResults.multiFaceLandmarks[0]);
    else {
        ctx.save(); ctx.globalAlpha=0.35+Math.sin(time*1.8)*0.08; ctx.fillStyle=PAL[currentColors].spore;
        ctx.font='11px Courier New'; ctx.textAlign='center'; ctx.fillText('FACE CAMERA TO ACTIVATE',W/2,H/2+55); ctx.restore();
    }
}

function drawTrackedAlien(lms) {
    const top    = lm(lms, TOP_IDX);
    const bottom = lm(lms, CHIN_IDX);
    const faceH  = bottom.y - top.y;
    const cx     = (top.x + bottom.x) / 2;
    const pal    = PAL[currentColors];

    ctx.save();
    ctx.globalCompositeOperation = 'source-over';

    // â”€â”€ 1. FACE PIXEL WARP â€” sample real video pixels, redraw stretched â”€â”€
    // We grab the face region from the live video and redraw it with:
    //   - cranium pushed up and widened (big alien dome)
    //   - jaw narrowed to a point (thin grey alien chin)
    // We do this with a triangle-mesh warp using small horizontal slices.

    // Face bounding box in canvas coords (mirrored to match video display)
    const faceTop    = top.y - faceH * 0.15;
    const faceBot    = bottom.y + faceH * 0.08;
    const faceLeft   = cx - faceH * 0.52;
    const faceRight  = cx + faceH * 0.52;
    const faceW      = faceRight - faceLeft;
    const srcFaceH   = faceBot - faceTop;

    // How much to elongate the cranium upward and taper the jaw
    const crownPush  = faceH * (0.42 + smoothBass * 0.08);  // pixels skull extends up
    const jawTaper   = 0.38;  // jaw narrows to this fraction of full width at chin

    const SLICES = 32;
    ctx.save();

    // Clip to avoid drawing outside face region
    const clipMargin = faceH * 0.6;
    ctx.beginPath();
    // Clip path: wide at crown, narrows at chin â€” alien silhouette
    ctx.moveTo(cx, faceTop - crownPush - 4);
    ctx.quadraticCurveTo(faceRight + clipMargin * 0.3, faceTop + srcFaceH * 0.3, cx + faceW * jawTaper * 0.5, faceBot + 4);
    ctx.lineTo(cx - faceW * jawTaper * 0.5, faceBot + 4);
    ctx.quadraticCurveTo(faceLeft - clipMargin * 0.3, faceTop + srcFaceH * 0.3, cx, faceTop - crownPush - 4);
    ctx.closePath();
    ctx.clip();

    for (let s = 0; s < SLICES; s++) {
        const t0 = s / SLICES;
        const t1 = (s + 1) / SLICES;

        // Source: horizontal strip from video (in video's coordinate space)
        // The video is mirrored via CSS scaleX(-1), so we read from the
        // mirrored video by flipping x when sampling
        const srcY0 = faceTop  + t0 * srcFaceH;
        const srcY1 = faceTop  + t1 * srcFaceH;
        const srcH  = srcY1 - srcY0;

        // Destination: stretched vertically + tapered horizontally
        // t=0 = top of face (crown), t=1 = chin
        // Crown gets pushed up; jaw narrows toward chin
        const dstY0 = (faceTop - crownPush) + t0 * (srcFaceH + crownPush);
        const dstY1 = (faceTop - crownPush) + t1 * (srcFaceH + crownPush);
        const dstH  = dstY1 - dstY0;

        // Width taper: full width near crown, narrow at chin
        const taper0 = 1.0 - t0 * (1.0 - jawTaper);
        const dstW   = faceW * taper0;
        const dstX   = cx - dstW / 2;

        // Draw this slice: source is a 1/SLICES strip, destination is stretched
        ctx.drawImage(
            video,
            // src: mirror the x so it matches the CSS-flipped video
            (video.videoWidth  - (faceRight  * (video.videoWidth  / W))) ,
            srcY0 * (video.videoHeight / H),
            faceW  * (video.videoWidth  / W),
            srcH   * (video.videoHeight / H),
            // dst on canvas
            dstX, dstY0, dstW, dstH
        );
    }
    ctx.restore();

    // â”€â”€ 2. Large dark wrap-around eyes over warped face â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Recalculate eye positions relative to the warp so they sit correctly
    const eyeVerticalShift = crownPush * 0.25; // eyes shift slightly with cranium

    [[L_EYE, 'L'], [R_EYE, 'R']].forEach(([eyeIdx, side]) => {
        const pts = eyeIdx.map(i => lm(lms, i));
        const ex  = pts.reduce((s, p) => s + p.x, 0) / pts.length;
        const ey  = pts.reduce((s, p) => s + p.y, 0) / pts.length + eyeVerticalShift;
        const ew  = Math.abs(pts[0].x - pts[8].x) * (1.85 + smoothBass * 0.4);
        const eh  = ew * 0.52;
        const tilt = side === 'L' ? -0.2 : 0.2; // classic alien upswept tilt

        ctx.globalAlpha = 0.90; ctx.fillStyle = '#050208';
        ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
        ctx.beginPath(); ctx.ellipse(ex, ey, ew, eh, tilt, 0, Math.PI * 2); ctx.fill();

        ctx.globalAlpha = 0.32 + smoothAvg * 0.22; ctx.fillStyle = pal.glow;
        ctx.shadowColor = pal.glow; ctx.shadowBlur = 14 + smoothAvg * 10;
        ctx.beginPath(); ctx.ellipse(ex, ey, ew * 0.6, eh * 0.52, tilt, 0, Math.PI * 2); ctx.fill();

        ctx.globalAlpha = 0.94; ctx.fillStyle = '#000'; ctx.shadowBlur = 0;
        ctx.beginPath(); ctx.ellipse(ex, ey, ew * 0.13, eh * 0.84, tilt, 0, Math.PI * 2); ctx.fill();

        ctx.globalAlpha = 0.75; ctx.fillStyle = 'rgba(255,255,255,0.92)';
        ctx.beginPath(); ctx.ellipse(ex - ew * 0.21, ey - eh * 0.23, ew * 0.09, eh * 0.09, tilt, 0, Math.PI * 2); ctx.fill();
    });

    // â”€â”€ 3. Bug antennae â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ctx.globalAlpha = 1;
    // Antennae base at the real hairline, which is now higher due to warp
    const antBaseY  = top.y - crownPush * 0.1 + 2;
    const antLen    = faceH * (0.62 + smoothMid * 0.18) + smoothBass * faceH * 0.16;

    [
        { bx: top.x - faceH * 0.18, by: antBaseY, tx: -faceH * 0.22, sway: -1 },
        { bx: top.x + faceH * 0.18, by: antBaseY, tx:  faceH * 0.22, sway:  1 }
    ].forEach(ant => {
        const tipX  = ant.bx + ant.tx + Math.sin(time * 2.1 + ant.sway) * 6;
        const tipY  = ant.by - antLen;
        const ctrlX = ant.bx + (tipX - ant.bx) * 0.4 + ant.sway * 9;
        const ctrlY = ant.by - antLen * 0.52;

        ctx.lineWidth = 1.8; ctx.strokeStyle = 'rgba(30,18,10,0.92)';
        ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.92; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(ant.bx, ant.by); ctx.quadraticCurveTo(ctrlX, ctrlY, tipX, tipY); ctx.stroke();

        ctx.lineWidth = 0.5; ctx.strokeStyle = 'rgba(200,180,150,0.28)';
        ctx.beginPath(); ctx.moveTo(ant.bx + 1, ant.by); ctx.quadraticCurveTo(ctrlX + 1, ctrlY, tipX + 1, tipY); ctx.stroke();

        const br = 4 + smoothBass * 2.8;
        ctx.globalAlpha = 0.93; ctx.fillStyle = '#110804'; ctx.shadowBlur = 0;
        ctx.beginPath(); ctx.arc(tipX, tipY, br, 0, Math.PI * 2); ctx.fill();

        ctx.globalAlpha = 0.54 + smoothAvg * 0.3; ctx.fillStyle = pal.glow;
        ctx.shadowColor = pal.glow; ctx.shadowBlur = 10 + smoothAvg * 12;
        ctx.beginPath(); ctx.arc(tipX, tipY, br * 0.62, 0, Math.PI * 2); ctx.fill();

        ctx.globalAlpha = 0.8; ctx.fillStyle = '#fff'; ctx.shadowBlur = 0;
        ctx.beginPath(); ctx.arc(tipX - br * 0.24, tipY - br * 0.26, br * 0.22, 0, Math.PI * 2); ctx.fill();
    });

    ctx.restore();
}

// â”€â”€ Snare / High-freq Slime Bursts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let prevRawHigh=0;
function spawnSlimeBurst() {
    if (!micActive) return;
    const now=Date.now();
    // Detect sharp high-freq transient (snare hit)
    const rise=rawHigh-prevRawHigh;
    if (rise>0.12 && rawHigh>0.35 && now-lastSnare>180) {
        lastSnare=now;
        const pal=PAL[currentColors];
        const count=4+Math.floor(rise*18); // 4-12 droplets per snare hit
        // Burst from 1-3 random positions across the frame edges (not center)
        const origins=[
            {x:Math.random()*W*0.3, y:H*0.1+Math.random()*H*0.4},
            {x:W*0.7+Math.random()*W*0.3, y:H*0.1+Math.random()*H*0.4},
            {x:W*0.2+Math.random()*W*0.6, y:H*0.05+Math.random()*H*0.2}
        ];
        const origin=origins[Math.floor(Math.random()*origins.length)];
        for (let i=0;i<count;i++) {
            const angle=Math.random()*Math.PI*2;
            const speed=1.5+Math.random()*4+rise*8;
            particles.push({
                x:origin.x, y:origin.y,
                vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed,
                size:3+Math.random()*6+rise*8,
                color:pal.slime, glow:pal.glow,
                life:1.0, fadeRate:0.028+Math.random()*0.02,
                type:'slime',
                stretch:0.4+Math.random()*0.6 // elongated drip shape
            });
        }
    }
    prevRawHigh=rawHigh;
}

// â”€â”€ Bass Flash â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function triggerBassFlash() {
    if (!micActive) return;
    const now=Date.now();
    if (smoothBass>0.48 && now-lastBassHit>120) {
        lastBassHit=now;
        const flash=document.getElementById('bassFlash');
        flash.style.background=`radial-gradient(ellipse at center, ${PAL[currentColors].flash} 0%, transparent 70%)`;
        flash.style.opacity=(smoothBass*0.7).toString();
        setTimeout(()=>flash.style.opacity='0',85);
    }
}

// â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addParticleEffects() {
    const pal=PAL[currentColors];
    const rate=micActive?0.20+smoothAvg*0.8:0.05;
    if (Math.random()<rate) {
        particles.push({ x:Math.random()*W, y:H+8, vx:(Math.random()-0.5)*1.1, vy:-0.6-Math.random()*1.3-smoothBass*1.4, size:0.8+Math.random()*2+smoothBass*2, color:pal.spore, glow:pal.glow, life:1.0, fadeRate:0.005+Math.random()*0.007, type:'ambient' });
    }
    if (smoothBass>0.44&&Math.random()<0.5) {
        for (let i=0;i<5;i++) particles.push({ x:W/2+(Math.random()-0.5)*240, y:H/2+(Math.random()-0.5)*240, vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5, size:1.2+Math.random()*2.8, color:pal.spore, glow:pal.glow, life:1.0, fadeRate:0.022, type:'ambient' });
    }
    for (let i=particles.length-1;i>=0;i--) {
        const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=p.fadeRate;
        if (p.life<=0||p.y<-50||p.x<-50||p.x>W+50) particles.splice(i,1);
    }
}

function renderParticles() {
    particles.forEach(p=>{
        ctx.save();
        if (p.type==='slime') {
            // Slime droplet â€” elongated teardrop in direction of velocity
            const speed=Math.sqrt(p.vx*p.vx+p.vy*p.vy);
            const angle=Math.atan2(p.vy,p.vx);
            const rx=Math.max(p.size*(0.4+speed*0.08), 2);
            const ry=p.size*(p.stretch||0.5);
            ctx.globalAlpha=p.life*0.82; ctx.fillStyle=p.color; ctx.shadowColor=p.glow; ctx.shadowBlur=8+smoothHigh*12;
            ctx.beginPath(); ctx.ellipse(p.x,p.y,rx,ry,angle,0,Math.PI*2); ctx.fill();
            // Inner highlight
            ctx.globalAlpha=p.life*0.4; ctx.fillStyle='rgba(255,255,255,0.6)'; ctx.shadowBlur=0;
            ctx.beginPath(); ctx.ellipse(p.x-rx*0.2,p.y-ry*0.2,rx*0.35,ry*0.3,angle,0,Math.PI*2); ctx.fill();
        } else {
            ctx.globalAlpha=p.life*0.72; ctx.fillStyle=p.color; ctx.shadowColor=p.glow; ctx.shadowBlur=5+smoothBass*8;
            ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();
    });
}

// â”€â”€ Render Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render() {
    if (!ctx||!canvas) return;
    ctx.clearRect(0,0,W,H);
    ctx.globalCompositeOperation='screen';
    renderPlants();
    renderParticles();
    ctx.globalCompositeOperation='source-over';
    renderAlienFace();
}

function startAnimation() {
    function animate() {
        if (cameraActive) {
            getAudioData();
            updatePlants();
            addParticleEffects();
            spawnSlimeBurst();
            triggerBassFlash();
            render();
            if (particles.length>320) particles.splice(0,particles.length-320);
        }
        requestAnimationFrame(animate);
    }
    animate();
}

// Auto-grow replacement plants
setInterval(()=>{
    if (!plantsActive||!W) return;
    if (plants.length<34) {
        const edges=['bottom','bottom','bottom','left','right'];
        const edge=edges[Math.floor(Math.random()*edges.length)];
        const pos=edge==='bottom'?Math.random()*W:H*(0.12+Math.random()*0.76);
        plants.push(makePlant(edge,pos));
    }
},2800);

document.addEventListener('touchmove',e=>e.preventDefault(),{passive:false});
document.addEventListener('gesturestart',e=>e.preventDefault());
document.addEventListener('gesturechange',e=>e.preventDefault());
window.addEventListener('orientationchange',()=>setTimeout(resizeCanvas,500));
</script>
</body>
</html>
